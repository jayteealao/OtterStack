# feat: Traefik Priority-Based Deployment Routing (Revised)

**Status:** Planning (Revised v2)
**Created:** 2026-01-09
**Type:** Enhancement
**Complexity:** Medium
**Risk:** Medium

---

## Overview

Implement zero-downtime deployments using Traefik's priority-based routing. OtterStack will inject timestamp-based priority labels via Compose override files, enabling instant traffic switching while maintaining old containers as rollback fallback.

**Changes from v1 Plan:**
- Simplified architecture: 1 package, 3 functions (no interfaces)
- Fixed health check flow: check BEFORE switching traffic (critical fix)
- Uses Compose override files instead of YAML injection
- Reduced from 15-22 days to 5-7 days
- Removed unnecessary configuration options

## Problem Statement

### Current Deployment Issues

OtterStack's current deployment flow:
1. Create worktree
2. Start new containers
3. Stop old containers
4. Mark deployment active

**Problems:**
- Brief downtime between stopping old and starting new containers
- No automatic rollback on health check failure
- Manual rollback requires full redeployment
- Previous deployment's containers are stopped (no quick rollback)

## Proposed Solution

### Correct Flow (Critical Fix)

```mermaid
graph LR
    A[Start Deploy] --> B[Generate Override File]
    B --> C[Start New Containers<br/>(NO Traefik labels)]
    C --> D[Health Check New Containers]
    D --> E{Healthy?}
    E -->|Yes| F[Add Priority Labels<br/>Traefik Switches Traffic]
    E -->|No| G[Stop New Containers<br/>Keep Old Running]
    F --> H[Stop Old Containers]
    G --> I[Mark Failed]
    H --> J[Mark Active]
```

**Key Insight:** Health check happens BEFORE Traefik routing changes. If unhealthy, traffic never switches.

### Traefik Integration via Override Files

Instead of modifying the user's compose file, OtterStack generates a `docker-compose.traefik.yml` override file:

```yaml
# Generated by OtterStack
services:
  web:
    labels:
      - "traefik.http.routers.web.priority=1704796800000"
  api:
    labels:
      - "traefik.http.routers.api.priority=1704796800000"
```

Docker Compose automatically merges override files. No YAML parsing needed.

## Technical Approach

### Architecture

**Single Package:** `internal/traefik/`

**Three Functions:**
```go
// traefik.go
func IsRunning(ctx context.Context) (bool, error)
func GenerateOverride(services []string, priority int64) (string, error)
func WaitForHealthy(ctx context.Context, composeProject string, timeout time.Duration) error
```

**That's it.** No interfaces. No structs. Just functions that work.

### Component Details

#### 1. Traefik Detection

```go
// internal/traefik/detect.go
package traefik

import (
    "context"
    "os/exec"
    "strings"
)

func IsRunning(ctx context.Context) (bool, error) {
    // Check for Traefik container
    cmd := exec.CommandContext(ctx, "docker", "ps",
        "--filter", "name=traefik",
        "--filter", "status=running",
        "--format", "{{.Names}}")

    output, err := cmd.Output()
    if err != nil {
        return false, nil // Traefik not found, not an error
    }

    return strings.Contains(string(output), "traefik"), nil
}
```

**Why this is simple:**
- No interface for a simple check
- Returns bool (true/false)
- No error if Traefik not found (degraded mode)

#### 2. Override File Generation

```go
// internal/traefik/override.go
package traefik

import (
    "fmt"
    "os"
    "path/filepath"
    "time"
)

func GenerateOverride(worktreePath string, priority int64) (string, error) {
    // Read user's compose file to find services
    composePath := filepath.Join(worktreePath, "docker-compose.yml")

    // Simple YAML parsing to find service names
    services, err := findServiceNames(composePath)
    if err != nil {
        return "", fmt.Errorf("failed to parse compose file: %w", err)
    }

    // Generate override file content
    overrideContent := "# Generated by OtterStack\n"
    for _, service := range services {
        overrideContent += fmt.Sprintf(`
services:
  %s:
    labels:
      - "traefik.http.routers.%s.priority=%d"
`, service, service, priority)
    }

    // Write override file
    overridePath := filepath.Join(worktreePath, "docker-compose.traefik.yml")
    if err := os.WriteFile(overridePath, []byte(overrideContent), 0644); err != nil {
        return "", fmt.Errorf("failed to write override file: %w", err)
    }

    return overridePath, nil
}
```

**Why this is simple:**
- Uses Compose's built-in override system
- No YAML AST manipulation
- Clean separation (override file vs user's compose file)
- Easy to delete/rollback

#### 3. Health Check

```go
// internal/traefik/health.go
package traefik

import (
    "context"
    "fmt"
    "os/exec"
    "time"
)

const DefaultHealthTimeout = 5 * time.Minute

func WaitForHealthy(ctx context.Context, composeProject string, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()

    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return fmt.Errorf("health check timeout after %v", timeout)
        case <-ticker.C:
            healthy, err := checkHealth(ctx, composeProject)
            if err != nil {
                return fmt.Errorf("health check failed: %w", err)
            }
            if healthy {
                return nil
            }
        }
    }
}

func checkHealth(ctx context.Context, composeProject string) (bool, error) {
    // Get container health status
    cmd := exec.CommandContext(ctx, "docker", "compose",
        "-p", composeProject,
        "ps", "--format", "{{.Name}}\t{{.Health}}")

    output, err := cmd.Output()
    if err != nil {
        return false, fmt.Errorf("failed to check health: %w", err)
    }

    // Parse output
    lines := strings.Split(string(output), "\n")
    for _, line := range lines {
        if line == "" {
            continue
        }
        parts := strings.Split(line, "\t")
        if len(parts) < 2 {
            continue
        }

        health := parts[1]
        if health == "" || health == "starting" || health == "unhealthy" {
            return false, nil // Not all healthy yet
        }
    }

    return true, nil // All containers healthy
}
```

**Why this is simple:**
- Single function with timeout
- Polls every 2 seconds
- Uses `docker compose ps` (already familiar)
- No interface for a simple operation

### Integration with Deployment Orchestrator

**File:** `internal/orchestrator/deployer.go`

**Changes:**

```go
// Add to Deployer struct
type Deployer struct {
    store        state.StateStore
    gitMgr       git.GitOperations
    composeMgr   compose.ComposeOperations
    traefikEnabled bool // New field
}

// In Deploy() method - updated flow
func (d *Deployer) Deploy(ctx context.Context, project *state.Project, ref string, opts DeployOptions) (*DeployResult, error) {
    // 1. ACQUIRE FILE LOCK (NEW - Critical Fix)
    lock := acquireDeploymentLock(project.Name)
    defer lock.Release()

    // 2. Pre-deployment (existing)
    deployment, err := d.store.CreateDeployment(...)

    // 3. Worktree creation (existing)
    worktreePath := ...

    // 4. Check if Traefik is running (NEW)
    var traefikAvailable bool
    if project.TraefikRoutingEnabled {
        traefikAvailable, _ = traefik.IsRunning(ctx)
        if !traefikAvailable {
            fmt.Println("Warning: Traefik not detected. Deployment will proceed without priority routing.")
        }
    }

    // 5. Start containers WITHOUT Traefik labels (CRITICAL CHANGE)
    // Old flow: Inject labels -> Start containers
    // New flow: Start containers -> Health check -> Inject labels

    composeProjectName := compose.GenerateProjectName(project.Name, shortSHA)

    if err := d.composeMgr.Up(ctx, worktreePath, composeProjectName, envFilePath); err != nil {
        return nil, fmt.Errorf("failed to start containers: %w", err)
    }

    // 6. Health check NEW containers (CRITICAL - BEFORE traffic switch)
    if project.TraefikRoutingEnabled && traefikAvailable {
        if err := traefik.WaitForHealthy(ctx, composeProjectName, traefik.DefaultHealthTimeout); err != nil {
            // UNHEALTHY: Stop new containers, keep old running
            d.composeMgr.Down(ctx, composeProjectName)
            d.store.UpdateDeploymentStatus(ctx, deployment.ID, "failed", &err)
            return nil, fmt.Errorf("health check failed: %w", err)
        }
    }

    // 7. Generate Traefik override file with priority labels (AFTER health check)
    if project.TraefikRoutingEnabled && traefikAvailable {
        priority := time.Now().UnixMilli()
        overridePath, err := traefik.GenerateOverride(worktreePath, priority)
        if err != nil {
            return nil, fmt.Errorf("failed to generate Traefik override: %w", err)
        }

        // Restart compose with override file (Traefik picks up new priority)
        if err := d.composeMgr.Up(ctx, worktreePath, composeProjectName, envFilePath, overridePath); err != nil {
            return nil, fmt.Errorf("failed to apply Traefik labels: %w", err)
        }
    }

    // 8. Stop old containers (existing)
    previousDeployment, _ := d.store.GetActiveDeployment(ctx, project.ID)
    if previousDeployment != nil {
        oldComposeProject := compose.GenerateProjectName(project.Name, git.ShortSHA(previousDeployment.GitSHA))
        d.composeMgr.Down(ctx, oldComposeProject)
    }

    // 9. Mark deployment active (existing)
    d.store.UpdateDeploymentStatus(ctx, deployment.ID, "active", nil)

    return &DeployResult{SHA: fullSHA}, nil
}
```

**Key Changes:**
1. File locking at start (prevents concurrent deployments)
2. Health check BEFORE Traefik label injection (critical safety fix)
3. Uses Compose override files instead of YAML injection
4. No new interfaces or components

### Database Changes

**Migration:** `internal/state/migrations/003_traefik_routing.sql`

```sql
BEGIN TRANSACTION;

-- Single column to enable/disable Traefik routing per project
ALTER TABLE projects ADD COLUMN traefik_routing_enabled BOOLEAN NOT NULL DEFAULT 0;

COMMIT;
```

**That's it.** No health_timeout column (use global constant). No new deployment states (use existing "failed").

### CLI Changes

**File:** `cmd/project.go`

```go
// Add flag to project add command
var projectAddCmd = &cobra.Command{
    Use:   "add <name> <path>",
    Short: "Add a new project",
    Args:  cobra.ExactArgs(2),
    RunE: func(cmd *cobra.Command, args []string) error {
        name := args[0]
        path := args[1]

        traefikRouting, _ := cmd.Flags().GetBool("traefik-routing")

        project := &state.Project{
            Name:                   name,
            RepoPath:              path,
            TraefikRoutingEnabled:  traefikRouting, // NEW
            // ... other fields
        }

        return store.CreateProject(ctx, project)
    },
}

// Add flag
projectAddCmd.Flags().Bool("traefik-routing", false, "Enable Traefik priority-based routing for zero-downtime deployments")
```

**File:** `cmd/deploy.go`

No new flags needed. Feature is controlled at project level.

### Concurrency Protection

**New file:** `internal/lock/deployment.go`

```go
package lock

import (
    "os"
    "path/filepath"
    "time"
)

type DeploymentLock struct {
    path string
    file *os.File
}

func AcquireDeploymentLock(dataDir, projectName string) (*DeploymentLock, error) {
    lockDir := filepath.Join(dataDir, "locks")
    os.MkdirAll(lockDir, 0755)

    lockPath := filepath.Join(lockDir, projectName+".lock")

    // Try to create exclusive lock file
    file, err := os.OpenFile(lockPath, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0644)
    if err != nil {
        return nil, fmt.Errorf("deployment already in progress (lock file exists)")
    }

    // Write PID for stale detection
    fmt.Fprintf(file, "%d\n", os.Getpid())
    fmt.Fprintf(file, "%s\n", time.Now().Format(time.RFC3339))

    return &DeploymentLock{
        path: lockPath,
        file: file,
    }, nil
}

func (l *DeploymentLock) Release() {
    if l.file != nil {
        l.file.Close()
    }
    os.Remove(l.path)
}
```

**Usage in deployer:**
```go
lock, err := lock.AcquireDeploymentLock(opts.DataDir, project.Name)
if err != nil {
    return nil, err
}
defer lock.Release()
```

## Implementation Plan

### Phase 1: Core Implementation (3-4 days)

**Tasks:**

1. **Database migration**
   - File: `internal/state/migrations/003_traefik_routing.sql`
   - Add `traefik_routing_enabled` column

2. **Traefik package**
   - File: `internal/traefik/detect.go`
   - File: `internal/traefik/override.go`
   - File: `internal/traefik/health.go`
   - Tests: `internal/traefik/*_test.go`

3. **Deployment lock**
   - File: `internal/lock/deployment.go`
   - Tests: `internal/lock/deployment_test.go`

4. **Update orchestrator**
   - File: `internal/orchestrator/deployer.go`
   - Add Traefik detection
   - Add health check before label injection
   - Add file locking

**Success Criteria:**
- All new code has unit tests
- Deployment flow works with Traefik
- Health check prevents unhealthy deployments

---

### Phase 2: CLI Integration (1-2 days)

**Tasks:**

1. **Update project command**
   - Add `--traefik-routing` flag
   - Update project add/edit logic

2. **Update deploy command**
   - No new flags (feature controlled at project level)

3. **Error messages**
   - Clear messages for common failures
   - Instructions for manual recovery if needed

**Success Criteria:**
- CLI commands work as expected
- Error messages are helpful

---

### Phase 3: Testing & Polish (1-2 days)

**Tasks:**

1. **Integration tests**
   - Test deployment with Traefik
   - Test rollback on health check failure
   - Test concurrent deployment blocking

2. **Manual testing**
   - Test with real Traefik setup
   - Test with real application
   - Verify no downtime during deployment

3. **Documentation**
   - Update README
   - Add troubleshooting section
   - Document new flag

**Success Criteria:**
- All tests pass
- Manual testing successful
- Documentation complete

---

**Total Effort:** 5-8 days

## Acceptance Criteria

### Functional Requirements

- [ ] **FR-1:** OtterStack detects running Traefik container
- [ ] **FR-2:** OtterStack generates Compose override file with priority labels
- [ ] **FR-3:** Health check runs BEFORE Traefik labels are applied (critical)
- [ ] **FR-4:** Unhealthy deployments do NOT switch traffic (critical)
- [ ] **FR-5:** Concurrent deployments are blocked by file lock (critical)
- [ ] **FR-6:** Healthy deployments switch traffic instantly via priority
- [ ] **FR-7:** Old containers are stopped after successful deployment
- [ ] **FR-8:** Feature is opt-in via `--traefik-routing` flag

### Non-Functional Requirements

- [ ] **NFR-1:** Zero code complexity increase (simple functions, no interfaces)
- [ ] **NFR-2:** Zero downtime during successful deployment
- [ ] **NFR-3:** Rollback within 5 seconds of health check failure
- [ ] **NFR-4:** No race conditions with concurrent deployments
- [ ] **NFR-5:** All existing tests still pass

### Quality Gates

- [ ] Unit test coverage > 80% for new code
- [ ] Integration tests pass with real Traefik
- [ ] Manual testing with real application successful
- [ ] Documentation complete

## Risk Analysis

| Risk | Mitigation |
|------|------------|
| Traefik not detected | Warning message, deployment continues without routing |
| Health check timeout | Configurable via code constant, clear error message |
| Concurrent deployment | File lock with clear error message |
| Old containers not running | Detect before deployment, error with clear message |
| Override file conflicts | Unique filename with timestamp, auto-cleanup |

## Success Metrics

- **Deployment reliability:** < 1% failures due to race conditions
- **Rollback time:** < 5 seconds from health check failure
- **Deployment time:** +health check duration only (no other overhead)
- **Code simplicity:** < 250 lines of new code (excluding tests)

## References

### External Documentation
- [Traefik HTTP Routers - Priority](https://doc.traefik.io/traefik/routing/routers/)
- [Docker Compose Override Files](https://docs.docker.com/compose/multiple-compose-files/merge/)
- [Zero-Downtime Deployments](https://traefik.io/blog/achieve-zero-downtime-deployments-with-traefik-and-kubernetes)

### Internal Files
- `internal/orchestrator/deployer.go:48-191` - Current deployment flow
- `internal/state/migrations/001_initial.sql` - Current schema
- `internal/compose/orchestrator.go` - Compose operations

### Related Issues
- None (new feature)

---

**Changes from v1:**
- ✅ Fixed health check flow (check BEFORE traffic switch)
- ✅ Uses Compose override files instead of YAML injection
- ✅ Simplified to 3 functions instead of 3 interfaces
- ✅ Added file locking for concurrency protection
- ✅ Removed unnecessary configuration options
- ✅ Reduced complexity from 15-22 days to 5-8 days
- ✅ Single database column instead of two
- ✅ No new deployment states

**Plan Status:** Ready for implementation (pending final approval)
